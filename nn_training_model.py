# -*- coding: utf-8 -*-
"""neuralnetworks.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mqQ-gdE9OqElXIVQb4PvNzXCF3o1K-sp
"""

import pandas as pd

df = pd.read_csv('train.csv')

# a function to extract titles of passengers
def get_title(name):
  if "." in name:
    return name.split(',')[1].split('.')[0].strip()
  else:
    return 'Unknown'

# A list with all the different titles
titles = sorted(set([x for x in df.Name.map(lambda x: get_title(x))]))

# normalize the titles
def replace_titles(x):
  title = x['Title']
  if title in ['Capt', 'Col', 'Major']:
    return 'Officer'
  elif title in ['Jonkheer', 'Don', 'the Countess', 'Dona', 'Lady', 'Sir']:
    return 'Royalty'
  elif title in ['the Countess', 'Mme', 'Lady']:
    return 'Mrs'
  elif title in ['Mlle', 'Ms']:
    return 'Miss'
  else:
    return title

df['Title'] = df['Name'].map(lambda x: get_title(x))

df['Title'] = df.apply(replace_titles, axis=1)

"""4Cs - Completing & Converting"""

# 4Cs - Completing & Converting data

df['Age'].fillna(df['Age'].median(), inplace=True)
df['Fare'].fillna(df['Fare'].median(), inplace=True)
df['Embarked'].fillna('S', inplace=True)
df.drop('Cabin',axis=1,inplace=True)
df.drop('Ticket',axis=1,inplace=True)
df.drop('Name',axis=1,inplace=True)
df.Sex.replace(('male','female'),(0,1),inplace=True)
df.Embarked.replace(('S','C','Q'),(0,1,2),inplace=True)
df.Title.replace(('Mr','Miss','Mrs','Master','Dr','Rev','Officer','Royalty'),(0,1,2,3,4,5,6,7),inplace=True)

# correlation between columns the the Y variable
corr = df.corr()
corr.Survived.sort_values(ascending=False)

# create train and test datasets
x = df.drop(['Survived','PassengerId'],axis=1)
y = df['Survived']

# import Sequential - Sequential can be considered as a placehoder for neural networks models
from keras.models import Sequential
# import Dense and Dropout
# 'Dense' in Keras refers to one 'hidden layer' in NN model.
# 'Dropout' as described previously, is randomly muting the nodes
from keras.layers import Dense, Dropout

# create a placeholder for neural network
model = Sequential()
# creating the first hidden layer with 32 nodes
# the activation function we use is 'relu'. relu is more popular than sigmoid as it doesn't
# have some of the issues that sigmoid has. (e.g. vanishing gradiant)
# input_shape shows the number of independent variables in the model
model.add(Dense(32, activation='relu', input_shape=(8,)))
# adding a few more hidden layers
model.add(Dense(32, activation='relu'))
model.add(Dense(5, activation='relu'))
# adding the output layer
# as the output for this model is 0 or 1, our output model only has 1 node
# also, as we want the output to be between 0 and 1, we can use sigmoid for activation
model.add(Dense(1, activation='sigmoid'))

# the next step if to 'compile' the model. the following items should be made clear here:
#   - what we want to use for back propagation (ex: optimizer='adam')
#   - how do we want to calculate the loss (ex: loss='binary_crossentropy')
#   - what metrics do we want to look at (ex: metrics=['accuracy'])
model.compile(optimizer='adam',loss='binary_crossentropy', metrics=['accuracy'])

# train the model
# epoch is the number of fwd and back calculations
# batch_size --> the number of titanic people we want to include in each epoch
# verbose --> how much info we want the model to tell us about the output
# validation_split --> what % of data we want to put in our validation
# predictors and target were defined in prev. steps
#x = predictors  # all independent variables
#y = target  # dependent variable
model_train = model.fit(x, y, epochs=100, batch_size=50, verbose=0, validation_split=0.1)

model.save('titanic_NN.h5')

# """load the saved NN model and do a prediction"""

# import numpy as np
# from keras.models import load_model
# model_predict = load_model('titanic_NN.h5')
# # inputs to the model should be in numpy array format
# x_example = np.array([[1,0,20,2,2,10,1,2]]) #Sex, Age, SibSp, Parch, Ticket, Fare, Cabin, Embarked

# prediction_num = model_predict.predict(x_example)

# print(prediction_num)

# if prediction_num < 0.5:
#   prediction = 'Not survived'
# else:
#   prediction = 'Survived!'

# print(prediction)


